import unittest
from unittest.mock import patch, MagicMock
import json
import base64
import boto3

# Import the module containing the original lambda function
# Replace 'your_module' with the actual module name where the lambda handler is defined
import your_module

class TestSecretRotationLambdaHandler(unittest.TestCase):
    def setUp(self):
        # Setup mock data and configurations
        self.secret_arn = 'arn:aws:secretsmanager:us-east-1:123456789012:secret:test-secret'
        self.request_token = 'test-request-token'
        self.test_password = 'new-test-password'

    @patch('boto3.client')
    def test_lambda_handler_rotation_not_enabled(self, mock_boto3_client):
        # Test scenario where rotation is not enabled for the secret
        mock_secrets_client = MagicMock()
        mock_boto3_client.return_value = mock_secrets_client

        # Configure mock to return rotation not enabled
        mock_secrets_client.describe_secret.return_value = {
            'RotationEnabled': False
        }

        event = {
            'SecretId': self.secret_arn,
            'ClientRequestToken': self.request_token,
            'Step': 'createSecret'
        }

        with self.assertRaises(ValueError) as context:
            your_module.lambda_handler(event, None)

        self.assertTrue('not enabled for rotation' in str(context.exception))

    @patch('boto3.client')
    def test_lambda_handler_create_secret_success(self, mock_boto3_client):
        # Test successful secret creation step
        mock_secrets_client = MagicMock()
        mock_boto3_client.return_value = mock_secrets_client

        # Configure mocks for successful secret creation
        mock_secrets_client.describe_secret.return_value = {
            'RotationEnabled': True,
            'VersionIdsToStages': {self.request_token: ['AWSPENDING']}
        }
        mock_secrets_client.get_secret_value.side_effect = [
            {'SecretString': json.dumps({'username': 'testuser', 'password': 'oldpassword'})},
            boto3.exceptions.botocore.exceptions.ClientError({'Error': {'Code': 'ResourceNotFoundException'}}, 'get_secret_value')
        ]
        mock_secrets_client.get_random_password.return_value = {
            'RandomPassword': self.test_password
        }

        event = {
            'SecretId': self.secret_arn,
            'ClientRequestToken': self.request_token,
            'Step': 'createSecret',
            'Password': self.test_password
        }

        # Call the lambda handler
        result = your_module.lambda_handler(event, None)
        self.assertIsNone(result)  # Successful operations typically return None

        # Verify client method calls
        mock_secrets_client.put_secret_value.assert_called_once()

    @patch('boto3.client')
    def test_lambda_handler_update_secret_success(self, mock_boto3_client):
        # Test successful secret update step
        mock_secrets_client = MagicMock()
        mock_boto3_client.return_value = mock_secrets_client

        # Configure mocks for successful secret update
        mock_secrets_client.get_secret_value.return_value = {
            'SecretString': json.dumps({'username': 'testuser', 'password': 'oldpassword'})
        }

        event = {
            'SecretId': self.secret_arn,
            'ClientRequestToken': self.request_token,
            'Step': 'updateSecret',
            'Password': self.test_password
        }

        # Call the lambda handler
        result = your_module.lambda_handler(event, None)
        self.assertIsNone(result)  # Successful operations typically return None

        # Verify client method calls
        mock_secrets_client.put_secret_value.assert_called_once()

    @patch('boto3.client')
    def test_lambda_handler_finish_secret_success(self, mock_boto3_client):
        # Test successful secret finalization step
        mock_secrets_client = MagicMock()
        mock_boto3_client.return_value = mock_secrets_client

        # Configure mocks for successful secret finalization
        mock_secrets_client.describe_secret.return_value = {
            'VersionIdsToStages': {
                'old-version': ['AWSCURRENT'],
                self.request_token: ['AWSPENDING']
            }
        }

        event = {
            'SecretId': self.secret_arn,
            'ClientRequestToken': self.request_token,
            'Step': 'finishSecret'
        }

        # Call the lambda handler
        result = your_module.lambda_handler(event, None)
        self.assertIsNone(result)  # Successful operations typically return None

        # Verify client method calls
        mock_secrets_client.update_secret_version_stage.assert_called_once()

    def test_execute_step_invalid_step(self):
        # Test handling of invalid step
        mock_client = MagicMock()

        with self.assertRaises(ValueError) as context:
            your_module.execute_step('invalidStep', mock_client, self.secret_arn, self.request_token, self.test_password)

        self.assertTrue('Invalid request step parameter' in str(context.exception))

    @patch('base64.b64encode')
    def test_create_secret_binary_handling(self, mock_base64_encode):
        # Test handling of binary secrets
        mock_client = MagicMock()
        mock_base64_encode.return_value = b'encoded-password'

        mock_client.get_secret_value.return_value = {
            'SecretBinary': b'current-binary-secret'
        }
        mock_client.get_random_password.return_value = {
            'RandomPassword': self.test_password
        }

        try:
            your_module.create_secret(mock_client, self.secret_arn, self.request_token)
            mock_client.put_secret_value.assert_called_once()
        except Exception as e:
            self.fail(f"create_secret raised an unexpected exception: {e}")

    def test_update_secret_json_parsing(self):
        # Test updating secrets with complex JSON structures
        mock_client = MagicMock()
        complex_secret = {
            'username': 'testuser',
            'credentials': {
                'password': 'oldpassword',
                'salt': 'oldsalt'
            }
        }

        mock_client.get_secret_value.return_value = {
            'SecretString': json.dumps(complex_secret)
        }

        try:
            your_module.update_secret(mock_client, self.secret_arn, self.test_password)
            mock_client.put_secret_value.assert_called_once()
            
            # Verify the updated secret
            updated_secret = json.loads(mock_client.put_secret_value.call_args[1]['SecretString'])
            self.assertEqual(updated_secret['credentials']['password'], self.test_password)
        except Exception as e:
            self.fail(f"update_secret raised an unexpected exception: {e}")

if __name__ == '__main__':
    unittest.main()
