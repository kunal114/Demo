import unittest
import json
import base64
import boto3
from moto import mock_secretsmanager
import sys
import os

# Add the directory containing the original script to the Python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Import the functions to test
from aws_secrets_rotation import (
    lambda_handler,
    create_secret,
    finish_secret,
    update_secret,
    EXCLUDE_CHARACTERS,
    PASSWORD_LENGTH
)

class TestSecretsManagerRotation(unittest.TestCase):
    def setUp(self):
        """
        Set up test environment before each test method
        """
        # Start mocking AWS Secrets Manager
        self.mock_secretsmanager = mock_secretsmanager()
        self.mock_secretsmanager.start()
        
        # Create a Secrets Manager client
        self.secretsmanager_client = boto3.client('secretsmanager', region_name='us-east-1')
        
        # Create a test secret
        self.test_secret_arn = self._create_test_secret()
    
    def tearDown(self):
        """
        Clean up after each test method
        """
        # Stop mocking AWS Secrets Manager
        self.mock_secretsmanager.stop()
    
    def _create_test_secret(self):
        """
        Helper method to create a test secret
        
        Returns:
            str: ARN of the created secret
        """
        response = self.secretsmanager_client.create_secret(
            Name='test-secret',
            SecretString='{"username": "testuser", "password": "initial_password"}'
        )
        return response['ARN']
    
    def test_create_secret_json(self):
        """
        Test creating a new secret version for a JSON-type secret
        """
        # Enable rotation for the secret
        self.secretsmanager_client.rotate_secret(
            SecretId=self.test_secret_arn,
            RotationRules={'AutomaticallyAfterDays': 30}
        )
        
        # Simulate create secret step
        request_token = 'test-rotation-token'
        new_password = 'new_test_password_123!'
        
        create_secret(
            self.secretsmanager_client, 
            self.test_secret_arn, 
            request_token, 
            new_password
        )
        
        # Verify the pending version exists
        response = self.secretsmanager_client.describe_secret(SecretId=self.test_secret_arn)
        
        # Check if the new version is in AWSPENDING stage
        pending_versions = [
            version for version, stages in response['VersionIdsToStages'].items() 
            if 'AWSPENDING' in stages
        ]
        self.assertEqual(len(pending_versions), 1)
        self.assertEqual(pending_versions[0], request_token)
        
        # Verify the secret value
        pending_secret = self.secretsmanager_client.get_secret_value(
            SecretId=self.test_secret_arn,
            VersionStage='AWSPENDING'
        )
        
        # Parse the secret and verify password update
        secret_dict = json.loads(pending_secret['SecretString'])
        self.assertEqual(secret_dict['password'], new_password)
    
    def test_create_secret_plaintext(self):
        """
        Test creating a new secret version for a plain text secret
        """
        # Create a plain text secret
        plain_secret_arn = self.secretsmanager_client.create_secret(
            Name='test-plain-secret',
            SecretString='initial_plain_password'
        )['ARN']
        
        # Enable rotation
        self.secretsmanager_client.rotate_secret(
            SecretId=plain_secret_arn,
            RotationRules={'AutomaticallyAfterDays': 30}
        )
        
        # Simulate create secret step
        request_token = 'test-rotation-token'
        new_password = 'new_test_password_123!'
        
        create_secret(
            self.secretsmanager_client, 
            plain_secret_arn, 
            request_token, 
            new_password
        )
        
        # Verify the pending version exists
        response = self.secretsmanager_client.describe_secret(SecretId=plain_secret_arn)
        
        # Check if the new version is in AWSPENDING stage
        pending_versions = [
            version for version, stages in response['VersionIdsToStages'].items() 
            if 'AWSPENDING' in stages
        ]
        self.assertEqual(len(pending_versions), 1)
        self.assertEqual(pending_versions[0], request_token)
        
        # Verify the secret value
        pending_secret = self.secretsmanager_client.get_secret_value(
            SecretId=plain_secret_arn,
            VersionStage='AWSPENDING'
        )
        
        self.assertEqual(pending_secret['SecretString'], new_password)
    
    def test_finish_secret(self):
        """
        Test finalizing secret rotation
        """
        # Create a secret with a pending version
        request_token = 'test-rotation-token'
        
        # First, create a pending version
        create_secret(
            self.secretsmanager_client, 
            self.test_secret_arn, 
            request_token, 
            'new_test_password_123!'
        )
        
        # Finish the secret rotation
        finish_secret(
            self.secretsmanager_client, 
            self.test_secret_arn, 
            request_token
        )
        
        # Verify the version stages
        response = self.secretsmanager_client.describe_secret(SecretId=self.test_secret_arn)
        
        # Check if the new version is now AWSCURRENT
        current_versions = [
            version for version, stages in response['VersionIdsToStages'].items() 
            if 'AWSCURRENT' in stages
        ]
        
        self.assertEqual(len(current_versions), 1)
        self.assertEqual(current_versions[0], request_token)
    
    def test_update_secret_json(self):
        """
        Test manually updating a JSON-type secret
        """
        new_password = 'manually_updated_password_456!'
        
        update_secret(
            self.secretsmanager_client, 
            self.test_secret_arn, 
            None,  # No request token for manual update
            new_password
        )
        
        # Retrieve the updated secret
        updated_secret = self.secretsmanager_client.get_secret_value(
            SecretId=self.test_secret_arn,
            VersionStage='AWSCURRENT'
        )
        
        # Parse the secret and verify password update
        secret_dict = json.loads(updated_secret['SecretString'])
        self.assertEqual(secret_dict['password'], new_password)
    
    def test_update_secret_plaintext(self):
        """
        Test manually updating a plain text secret
        """
        # Create a plain text secret
        plain_secret_arn = self.secretsmanager_client.create_secret(
            Name='test-plain-update-secret',
            SecretString='initial_plain_password'
        )['ARN']
        
        new_password = 'manually_updated_password_789!'
        
        update_secret(
            self.secretsmanager_client, 
            plain_secret_arn, 
            None,  # No request token for manual update
            new_password
        )
        
        # Retrieve the updated secret
        updated_secret = self.secretsmanager_client.get_secret_value(
            SecretId=plain_secret_arn,
            VersionStage='AWSCURRENT'
        )
        
        self.assertEqual(updated_secret['SecretString'], new_password)
    
    def test_lambda_handler_manual_update(self):
        """
        Test lambda_handler for manual secret update
        """
        event = {
            'SecretId': self.test_secret_arn,
            'Password': 'lambda_manual_update_password!'
        }
        
        # Call lambda_handler for manual update
        lambda_handler(event, None)
        
        # Retrieve the updated secret
        updated_secret = self.secretsmanager_client.get_secret_value(
            SecretId=self.test_secret_arn,
            VersionStage='AWSCURRENT'
        )
        
        # Parse the secret and verify password update
        secret_dict = json.loads(updated_secret['SecretString'])
        self.assertEqual(secret_dict['password'], event['Password'])
    
    def test_lambda_handler_rotation_create_secret(self):
        """
        Test lambda_handler for secret rotation create step
        """
        # Enable rotation for the secret
        self.secretsmanager_client.rotate_secret(
            SecretId=self.test_secret_arn,
            RotationRules={'AutomaticallyAfterDays': 30}
        )
        
        event = {
            'SecretId': self.test_secret_arn,
            'ClientRequestToken': 'test-rotation-token',
            'Step': 'createSecret'
        }
        
        # Call lambda_handler for create secret step
        lambda_handler(event, None)
        
        # Verify the pending version exists
        response = self.secretsmanager_client.describe_secret(SecretId=self.test_secret_arn)
        
        # Check if the new version is in AWSPENDING stage
        pending_versions = [
            version for version, stages in response['VersionIdsToStages'].items() 
            if 'AWSPENDING' in stages
        ]
        self.assertEqual(len(pending_versions), 1)
        self.assertEqual(pending_versions[0], event['ClientRequestToken'])
    
    def test_invalid_secret_arn(self):
        """
        Test handling of invalid secret ARN
        """
        with self.assertRaises(ValueError):
            lambda_handler({}, None)
    
    def test_rotation_not_enabled(self):
        """
        Test handling of secret rotation not being enabled
        """
        with self.assertRaises(ValueError):
            lambda_handler({
                'SecretId': self.test_secret_arn,
                'ClientRequestToken': 'test-token',
                'Step': 'createSecret'
            }, None)

if __name__ == '__main__':
    unittest.main()
