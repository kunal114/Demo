@Test
public void test_getRestTemplate() throws Exception {
    MockitoAnnotations.openMocks(this);
    
    try (MockedStatic<KeyStore> mockedKeyStore = mockStatic(KeyStore.class);
         MockedStatic<FileInputStream> mockedFileInputStream = mockStatic(FileInputStream.class)) {
        
        Mockito.mockConstruction(SSLContextBuilder.class, (mock, context) -> {
            when(mock.useProtocol(anyString())).thenReturn(mock);
            when(mock.loadTrustMaterial(Mockito.any(KeyStore.class), Mockito.any(TrustSelfSignedStrategy.class))).thenReturn(mock);
            when(mock.build()).thenReturn(sslContext);
        });
        
        Mockito.mockConstruction(SSLConnectionSocketFactory.class);
        
        mockedKeyStore.when(() -> KeyStore.getInstance(anyString())).thenReturn(keyStore);
        
        String keystorePath = RestTemplateFactoryTest.class.getClassLoader().getResource("thapp-secure/appids.jks").getPath();
        ReflectionTestUtils.setField(restTemplateFactory, "keyStorePath", keystorePath);
        
        FileInputStream mockFileInputStream = mock(FileInputStream.class);
        mockedFileInputStream.when(() -> new FileInputStream(keystorePath)).thenReturn(mockFileInputStream);
        
        when(secureCredential.getKeystorePassword()).thenReturn("changeit");
        
        RestTemplate restTemplate = restTemplateFactory.getRestTemplate();
        
        Assertions.assertNotNull(restTemplate);
        
        // Verify FileInputStream was created with the correct path
        mockedFileInputStream.verify(() -> new FileInputStream(keystorePath));
        
        // Verify KeyStore.load was called with the mocked FileInputStream
        verify(keyStore).load(eq(mockFileInputStream), any(char[].class));
    }
}
