import unittest
from unittest.mock import patch, MagicMock
import json
import base64
import boto3

# Adjust this import to match your actual module name
import lambda_function as your_module

class TestSecretRotationLambda(unittest.TestCase):
    def setUp(self):
        # Setup common test data
        self.secret_arn = 'arn:aws:secretsmanager:us-east-1:123456789012:secret:test-secret'
        self.request_token = 'test-request-token'
        self.test_password = 'new-test-password'

    def test_invalid_step(self):
        # Verify that an invalid step raises a ValueError
        mock_client = MagicMock()

        with self.assertRaises(ValueError) as context:
            your_module.execute_step(
                'invalidStep', 
                mock_client, 
                self.secret_arn, 
                self.request_token, 
                self.test_password
            )
        
        self.assertTrue('Invalid request step parameter' in str(context.exception))

    @patch('boto3.client')
    def test_lambda_handler_rotation_disabled(self, mock_boto3_client):
        # Test handling when rotation is not enabled
        mock_secrets_client = MagicMock()
        mock_boto3_client.return_value = mock_secrets_client

        # Mock describe_secret to return rotation as disabled
        mock_secrets_client.describe_secret.return_value = {
            'RotationEnabled': False
        }

        event = {
            'SecretId': self.secret_arn,
            'ClientRequestToken': self.request_token,
            'Step': 'createSecret'
        }

        with self.assertRaises(ValueError) as context:
            your_module.lambda_handler(event, None)
        
        self.assertTrue('not enabled for rotation' in str(context.exception))

    @patch('boto3.client')
    def test_execute_step_create_secret(self, mock_boto3_client):
        # Test the createSecret step
        mock_secrets_client = MagicMock()
        mock_boto3_client.return_value = mock_secrets_client

        # Mock current secret retrieval
        mock_secrets_client.get_secret_value.return_value = {
            'SecretString': json.dumps({
                'username': 'testuser', 
                'password': 'oldpassword'
            })
        }

        # Mock random password generation
        mock_secrets_client.get_random_password.return_value = {
            'RandomPassword': self.test_password
        }

        try:
            your_module.execute_step(
                'createSecret', 
                mock_secrets_client, 
                self.secret_arn, 
                self.request_token, 
                self.test_password
            )
        except Exception as e:
            self.fail(f"createSecret step raised unexpected exception: {e}")

    @patch('boto3.client')
    def test_execute_step_update_secret(self, mock_boto3_client):
        # Test the updateSecret step
        mock_secrets_client = MagicMock()
        mock_boto3_client.return_value = mock_secrets_client

        # Mock current secret retrieval
        mock_secrets_client.get_secret_value.return_value = {
            'SecretString': json.dumps({
                'username': 'testuser', 
                'password': 'oldpassword'
            })
        }

        try:
            your_module.execute_step(
                'updateSecret', 
                mock_secrets_client, 
                self.secret_arn, 
                self.request_token, 
                self.test_password
            )
        except Exception as e:
            self.fail(f"updateSecret step raised unexpected exception: {e}")

    @patch('boto3.client')
    def test_execute_step_finish_secret(self, mock_boto3_client):
        # Test the finishSecret step
        mock_secrets_client = MagicMock()
        mock_boto3_client.return_value = mock_secrets_client

        # Mock describe_secret to return version stages
        mock_secrets_client.describe_secret.return_value = {
            'VersionIdsToStages': {
                'old-version': ['AWSCURRENT'],
                self.request_token: ['AWSPENDING']
            }
        }

        try:
            your_module.execute_step(
                'finishSecret', 
                mock_secrets_client, 
                self.secret_arn, 
                self.request_token, 
                self.test_password
            )
        except Exception as e:
            self.fail(f"finishSecret step raised unexpected exception: {e}")

    def test_supported_steps(self):
        # Verify all supported steps can be processed
        supported_steps = [
            'createSecret', 
            'setSecret', 
            'testSecret', 
            'finishSecret', 
            'updateSecret'
        ]

        mock_client = MagicMock()
        for step in supported_steps:
            try:
                your_module.execute_step(
                    step, 
                    mock_client, 
                    self.secret_arn, 
                    self.request_token, 
                    self.test_password
                )
            except Exception as e:
                self.fail(f"Step {step} failed unexpectedly: {e}")

    def test_secret_value_parsing(self):
        # Test handling of different secret value formats
        test_cases = [
            # Simple string secret
            'plain_text_password',
            # JSON secret
            json.dumps({'password': 'nested_password'}),
            # Complex JSON secret
            json.dumps({
                'credentials': {
                    'password': 'complex_password',
                    'username': 'test_user'
                }
            })
        ]

        mock_client = MagicMock()
        for secret_value in test_cases:
            try:
                # Simulate get_secret_value returning different types of secrets
                mock_client.get_secret_value.return_value = {
                    'SecretString': secret_value
                }
                
                your_module.update_secret(
                    mock_client, 
                    self.secret_arn, 
                    self.test_password
                )
            except Exception as e:
                self.fail(f"Failed to handle secret value: {secret_value}. Error: {e}")

if __name__ == '__main__':
    unittest.main(verbosity=2)
