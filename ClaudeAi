import pandas as pd
import numpy as np

class CategoricalHandler:
    """
    Handles the segmentation of data based on categorical features and 
    manages conditional logic discovery.
    """
    
    def __init__(self, categorical_cols=None):
        """
        Initialize the CategoricalHandler.
        
        Args:
            categorical_cols (list): List of column names that are categorical
        """
        self.categorical_cols = categorical_cols or []
        
    def segment_data(self, input_df):
        """
        Segment the input data based on combinations of categorical features.
        
        Args:
            input_df (pd.DataFrame): The input dataset
            
        Returns:
            dict: Dictionary of segmented DataFrames with segment names as keys
        """
        if not self.categorical_cols:
            return {'all_data': input_df.copy()}
        
        segments = {}
        
        # Create a unique segment ID for each unique combination of categorical values
        if len(self.categorical_cols) == 1:
            # Single categorical column case
            cat_col = self.categorical_cols[0]
            unique_values = input_df[cat_col].unique()
            
            for value in unique_values:
                segment_name = f"{cat_col}='{value}'"
                segment_df = input_df[input_df[cat_col] == value].copy()
                segments[segment_name] = segment_df
        else:
            # Multiple categorical columns case
            # Create a cartesian product of all possible combinations
            combined_categories = input_df[self.categorical_cols].drop_duplicates()
            
            for _, row in combined_categories.iterrows():
                segment_conditions = ' AND '.join([f"{col}='{row[col]}'" for col in self.categorical_cols])
                
                # Create mask for this combination
                mask = True
                for col in self.categorical_cols:
                    mask = mask & (input_df[col] == row[col])
                
                segment_df = input_df[mask].copy()
                segments[segment_conditions] = segment_df
        
        return segments
    
    def get_corresponding_output(self, output_df, segment_df):
        """
        Get the corresponding output data for a given input segment.
        
        Args:
            output_df (pd.DataFrame): The full output dataset
            segment_df (pd.DataFrame): A segment of the input dataset
            
        Returns:
            pd.DataFrame: The corresponding rows from the output dataset
        """
        # Assuming output_df has the same row ordering as input_df
        # In real-world scenarios, you'd need a key to match rows
        segment_indices = segment_df.index
        return output_df.loc[segment_indices].copy()
    
    def combine_segment_rules(self, rules_by_segment):
        """
        Combine segment-specific rules into conditional expressions.
        
        Args:
            rules_by_segment (dict): Dictionary of rules by segment
            
        Returns:
            str: A combined rule expression with conditional logic
        """
        if len(rules_by_segment) == 1:
            # If there's only one segment, return its rule
            return next(iter(rules_by_segment.values()))
        
        combined_rule = "CASE\n"
        for segment, rule in rules_by_segment.items():
            combined_rule += f"  WHEN {segment} THEN {rule}\n"
        combined_rule += "END"
        
        return combined_rule
