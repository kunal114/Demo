import unittest
import json
import logging
from unittest.mock import patch, MagicMock

# Configure logging
logging.basicConfig(level=logging.DEBUG, 
                    format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Adjust this import to match your actual module name
import lambda_function as your_module

class TestSecretRotationLambda(unittest.TestCase):
    def setUp(self):
        # Setup common test data
        self.secret_arn = 'arn:aws:secretsmanager:us-east-1:123456789012:secret:test-secret'
        self.request_token = 'test-request-token'
        self.test_password = 'new-test-password'

    def _safe_execute_step(self, step, client, secret_arn, request_token, password):
        """
        Safely execute a step with detailed logging
        """
        try:
            logger.debug(f"Attempting to execute step: {step}")
            result = your_module.execute_step(step, client, secret_arn, request_token, password)
            logger.debug(f"Step {step} executed successfully")
            return result
        except Exception as e:
            logger.error(f"Error in step {step}: {e}")
            logger.error(f"Exception type: {type(e)}")
            # Print out the full traceback
            import traceback
            logger.error(traceback.format_exc())
            raise

    def test_supported_steps(self):
        """
        Test all supported steps with detailed error handling and logging
        """
        supported_steps = [
            'createSecret', 
            'setSecret', 
            'testSecret', 
            'finishSecret', 
            'updateSecret'
        ]

        # Create a mock client with detailed logging
        mock_client = MagicMock()
        
        # Configure mock client behaviors
        mock_client.describe_secret.return_value = {
            'RotationEnabled': True,
            'VersionIdsToStages': {
                self.request_token: ['AWSPENDING']
            }
        }
        mock_client.get_secret_value.return_value = {
            'SecretString': json.dumps({
                'username': 'testuser', 
                'password': 'oldpassword'
            })
        }
        mock_client.get_random_password.return_value = {
            'RandomPassword': self.test_password
        }

        # Track failed steps
        failed_steps = []

        # Test each step
        for step in supported_steps:
            try:
                logger.info(f"Testing step: {step}")
                self._safe_execute_step(
                    step, 
                    mock_client, 
                    self.secret_arn, 
                    self.request_token, 
                    self.test_password
                )
            except Exception as e:
                logger.error(f"Step {step} failed")
                failed_steps.append((step, str(e)))

        # If any steps failed, fail the test
        if failed_steps:
            error_msg = "Some steps failed:\n" + "\n".join(
                f"{step}: {error}" for step, error in failed_steps
            )
            self.fail(error_msg)

    def test_execute_step_update_secret(self):
        """
        Comprehensive test for update secret step
        """
        # Detailed test cases for different secret formats
        test_cases = [
            # Simple string secret
            {'input': 'plain_text_password', 'type': 'plain'},
            # JSON secret with password
            {'input': json.dumps({'password': 'old_password'}), 'type': 'simple_json'},
            # Complex JSON secret
            {'input': json.dumps({
                'credentials': {
                    'password': 'old_password',
                    'username': 'test_user'
                }
            }), 'type': 'complex_json'}
        ]

        for case in test_cases:
            try:
                # Create a fresh mock client for each test
                mock_client = MagicMock()
                
                # Configure mock client behavior
                mock_client.get_secret_value.return_value = {
                    'SecretString': case['input']
                }

                # Log the test case details
                logger.info(f"Testing update_secret with {case['type']} secret")

                # Attempt to update the secret
                your_module.update_secret(
                    mock_client, 
                    self.secret_arn, 
                    self.test_password
                )

                # Verify put_secret_value was called
                mock_client.put_secret_value.assert_called_once()
                logger.info(f"Successfully updated {case['type']} secret")

            except Exception as e:
                logger.error(f"Failed to update {case['type']} secret")
                logger.error(f"Exception: {e}")
                import traceback
                logger.error(traceback.format_exc())
                self.fail(f"Failed to update {case['type']} secret: {e}")

    def test_secret_value_parsing(self):
        """
        Detailed test for secret value parsing
        """
        # Comprehensive test cases for different secret formats
        test_cases = [
            # Simple string secret
            {'input': 'plain_text_password', 'expected': self.test_password},
            
            # JSON secret with password
            {'input': json.dumps({'password': 'old_password'}), 
             'expected': json.dumps({'password': self.test_password})},
            
            # Complex nested JSON secret
            {'input': json.dumps({
                'credentials': {
                    'password': 'old_password',
                    'username': 'test_user'
                }
            }), 
             'expected': json.dumps({
                'credentials': {
                    'password': self.test_password,
                    'username': 'test_user'
                }
             })}
        ]

        for case in test_cases:
            try:
                # Create a fresh mock client for each test
                mock_client = MagicMock()
                
                # Configure mock client behavior
                mock_client.get_secret_value.return_value = {
                    'SecretString': case['input']
                }

                # Log the test case details
                logger.info(f"Testing secret parsing: {case['input']}")

                # Call update_secret method
                your_module.update_secret(
                    mock_client, 
                    self.secret_arn, 
                    self.test_password
                )

                # Verify put_secret_value was called with expected value
                mock_client.put_secret_value.assert_called_once()
                
                # Additional verification of the secret value
                call_args = mock_client.put_secret_value.call_args[1]
                self.assertIn('SecretString', call_args)
                
                # Log successful parsing
                logger.info("Secret parsing successful")

            except Exception as e:
                logger.error(f"Failed to parse secret: {case['input']}")
                logger.error(f"Exception: {e}")
                import traceback
                logger.error(traceback.format_exc())
                self.fail(f"Failed to parse secret {case['input']}: {e}")

if __name__ == '__main__':
    # Configure more verbose logging
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Run tests with verbose output
    unittest.main(verbosity=2)
